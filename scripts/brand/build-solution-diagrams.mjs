#!/usr/bin/env node
/**
 * Solution diagram optimizer.
 *
 * This script mirrors the icon build pipeline by running SVGO over raw artwork living under
 * `assets/solutions-diagrams/raw/` and emitting production-ready SVGs into
 * `public/static/diagrams/solutions/`.
 *
 * The implementation intentionally exports a reusable `buildSolutionDiagrams` helper so Vitest can
 * exercise the pipeline end-to-end. Keeping the logic here instead of sprinkling bespoke shell
 * scripts ensures designers only maintain raw assets while automation maintains deterministic
 * output. Comments remain verbose per repository convention so future contributors understand the
 * automation guardrails at a glance.
 */
import { mkdir, readdir, readFile, rm, writeFile } from 'node:fs/promises';
import { existsSync } from 'node:fs';
import { createRequire } from 'node:module';
import { join, relative } from 'node:path';
import process from 'node:process';
import { fileURLToPath } from 'node:url';

import { optimize } from 'svgo';

const require = createRequire(import.meta.url);
const svgoConfig = require('../../svgo.config.cjs');
const repositoryRoot = fileURLToPath(new URL('../..', import.meta.url));

/**
 * Deterministic banner appended to every optimized SVG so humans know where the asset is sourced
 * from. This mirrors the React icon pipeline pattern and prevents manual edits to compiled output.
 */
const bannerComment =
  '<!-- Auto-generated by scripts/brand/build-solution-diagrams.mjs. Edit assets/solutions-diagrams/raw/*.svg instead. -->\n';

/**
 * Optimize and optionally check solution diagrams.
 *
 * @param {Object} options - Runtime configuration.
 * @param {string} [options.rootDir=repositoryRoot] - Root directory housing the assets.
 * @param {boolean} [options.check=false] - When true, verifies output matches generated content.
 * @returns {Promise<void>}
 */
export async function buildSolutionDiagrams({ rootDir = repositoryRoot, check = false } = {}) {
  // Resolve directories relative to the configurable root for testing flexibility.
  const rawDir = join(rootDir, 'assets/solutions-diagrams/raw');
  const outputDir = join(rootDir, 'public/static/diagrams/solutions');

  // Guard against missing directories so CI fails loudly when prerequisites are absent.
  if (!existsSync(rawDir)) {
    throw new Error(`Missing raw solution diagram directory: ${rawDir}`);
  }

  await mkdir(outputDir, { recursive: true });

  const rawFiles = (await readdir(rawDir)).filter((file) => file.endsWith('.svg'));

  // Ensure stale optimized assets are removed so designers do not have to prune files manually.
  const outputFiles = existsSync(outputDir)
    ? (await readdir(outputDir)).filter((file) => file.endsWith('.svg'))
    : [];
  const staleFiles = outputFiles.filter((file) => !rawFiles.includes(file));

  if (staleFiles.length > 0) {
    if (check) {
      const staleList = staleFiles.map((file) => relative(rootDir, join(outputDir, file))).join('\n - ');
      throw new Error(
        `Stale optimized diagrams detected. Remove them by running npm run diagrams:build:\n - ${staleList}`,
      );
    }

    await Promise.all(
      staleFiles.map(async (file) => {
        await rm(join(outputDir, file));
      }),
    );
  }

  // Optimize each diagram deterministically. We read the file before optimizing so the check mode
  // can compare the optimized output without mutating the filesystem.
  await Promise.all(
    rawFiles.map(async (file) => {
      const rawPath = join(rawDir, file);
      const outputPath = join(outputDir, file);

      const svgSource = await readFile(rawPath, 'utf8');
      const optimized = optimize(svgSource, { ...svgoConfig, path: rawPath });
      const contents = `${bannerComment}${optimized.data.trim()}\n`;

      if (check) {
        if (!existsSync(outputPath)) {
          throw new Error(
            `Missing optimized diagram for ${relative(rootDir, rawPath)}. Run npm run diagrams:build to generate it.`,
          );
        }
        const current = await readFile(outputPath, 'utf8');
        if (current !== contents) {
          throw new Error(
            `Outdated optimized diagram: ${relative(rootDir, outputPath)}. Run npm run diagrams:build to update it.`,
          );
        }
        return;
      }

      await writeFile(outputPath, contents, 'utf8');
    }),
  );
}

/**
 * Lightweight CLI wrapper. Parsing is intentionally minimalâ€”flags mirror existing asset build
 * scripts so local developer muscle memory stays intact.
 */
async function runCli() {
  const args = new Set(process.argv.slice(2));
  const check = args.has('--check') || args.has('-c');

  await buildSolutionDiagrams({ rootDir: repositoryRoot, check });
}

if (process.argv[1] && fileURLToPath(import.meta.url) === process.argv[1]) {
  runCli().catch((error) => {
    console.error(error instanceof Error ? error.message : error);
    process.exitCode = 1;
  });
}
